<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Web Logic Simulator</title>
<style>
  /* --- ãƒ‡ã‚¶ã‚¤ãƒ³è¨­å®š --- */
  body { margin:0; overflow:hidden; background:#1e1e1e; font-family:'Meiryo', 'Segoe UI', sans-serif; display:flex; height:100vh; color:#ddd; }
  
  /* ã‚µã‚¤ãƒ‰ãƒãƒ¼å·¦å³åˆ‡ã‚Šæ›¿ãˆç”¨è¨­å®š */
  body.sidebar-right { flex-direction: row-reverse; }
  body.sidebar-right #sidebar { border-right: none; border-left: 1px solid #333; }

  /* ã‚µã‚¤ãƒ‰ãƒãƒ¼ */
  #sidebar { width:280px; background:#252525; border-right:1px solid #333; display:flex; flex-direction:column; padding:10px; box-sizing:border-box; user-select:none; z-index:10; overflow-y:auto; }
  #sidebar::-webkit-scrollbar { width: 8px; }
  #sidebar::-webkit-scrollbar-track { background: #252525; }
  #sidebar::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
  #sidebar::-webkit-scrollbar-thumb:hover { background: #555; }

  .cat-title { font-size:12px; color:#aaa; margin:15px 0 5px 0; font-weight:bold; border-bottom:1px solid #444; padding-bottom:2px; }
  .cat-title:first-child { margin-top: 0; }

  /* ãƒ„ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ */
  .tool-btn { display:flex; align-items:center; gap:10px; padding:6px 10px; margin-bottom:4px; background:#333; border:1px solid #444; border-radius:4px; cursor:grab; font-size:13px; color:#ccc; flex-shrink: 0; transition:all 0.1s; }
  .tool-btn:hover { background: #444; border-color: #666; color: #fff; transform: translateX(2px); }
  .tool-btn:active { cursor: grabbing; transform: scale(0.98); }
  .icon { width: 20px; text-align: center; }

  /* ä¸‹éƒ¨ãƒ„ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ */
  .tools-area { margin-top: auto; border-top: 1px solid #444; padding-top: 10px; }
  .action-row { display: flex; gap: 5px; margin-bottom: 5px; }
  .action-btn { flex:1; padding:8px; cursor:pointer; border:none; border-radius:4px; font-weight:bold; color:white; font-size:12px; display:flex; justify-content:center; align-items:center; transition: background 0.2s; }
  .action-btn:hover { opacity: 0.9; }

  .btn-mode { background: #444; border: 1px solid #555; }
  .btn-mode.active { background: #0078d4; border-color: #005a9e; box-shadow: inset 0 0 5px rgba(0,0,0,0.5); }
  .btn-create { background: #e65100; width: 100%; margin-bottom:10px; font-size:13px; }
  .btn-save { background: #2b88d8; }
  .btn-io { background:#546e7a; width:100%; margin-bottom:5px; }
  .btn-clear { background:#d13438; width:100%; }
  .btn-side { background:#607d8b; width:100%; margin-bottom:5px; } /* ã‚µã‚¤ãƒ‰åˆ‡æ›¿ç”¨ */

  /* ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼å¯¾å¿œï¼‰ */
  #canvas-container { flex: 1; position: relative; cursor: default; overflow: auto; background: #1e1e1e; }
  #canvas-container::-webkit-scrollbar { width: 14px; height: 14px; }
  #canvas-container::-webkit-scrollbar-track { background: #1e1e1e; }
  #canvas-container::-webkit-scrollbar-thumb { background: #333; border: 3px solid #1e1e1e; border-radius: 10px; }
  #canvas-container::-webkit-scrollbar-thumb:hover { background: #444; }

  /* ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç”¨ã®ãƒ€ãƒŸãƒ¼è¦ç´ ï¼ˆåºƒå¤§ãªé ˜åŸŸã‚’ç¢ºä¿ï¼‰ */
  #scroll-spacer { width: 10000px; height: 10000px; pointer-events: none; }
  canvas { position: sticky; top: 0; left: 0; display: block; outline: none; z-index: 1; }

  /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼ */
  #status-bar { position:sticky; bottom:0; left:0; right:0; height:26px; background:#0078d4; color:white; font-size:12px; line-height:26px; padding:0 10px; opacity:0.95; display:flex; justify-content:space-between; pointer-events:none; z-index: 5; }

  /* ãƒ¢ãƒ¼ãƒ€ãƒ« (ãƒ†ã‚­ã‚¹ãƒˆå…¥å‡ºåŠ›) */
  #io-modal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:100; justify-content:center; align-items:center; }
  .modal-content { background: #2d2d2d; padding: 20px; border-radius: 8px; width: 600px; border: 1px solid #555; box-shadow: 0 10px 25px rgba(0,0,0,0.5); }
  .modal-content h3 { margin-top: 0; color: #fff; border-bottom: 1px solid #444; padding-bottom: 10px; }
  .modal-content textarea { width: 100%; height: 300px; background: #111; color: #0f0; border: 1px solid #444; font-family: monospace; font-size: 11px; margin-bottom: 10px; resize: vertical; box-sizing: border-box; padding: 5px; }
  .modal-btns { display: flex; gap: 10px; justify-content: flex-end; }
  #file-input { display: none; }

  /* è¨€èªåˆ‡ã‚Šæ›¿ãˆ */
  #lang-select { background: #333; color: #ddd; border: 1px solid #555; padding: 5px; width: 100%; margin-bottom: 10px; font-size: 12px; border-radius: 4px; }
  
  /* é€Ÿåº¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ç”¨ */
  .speed-control { padding: 0 5px 10px 5px; color:#ccc; font-size:12px; }
  .speed-control input { width: 100%; cursor: pointer; }
</style>
</head>
<body>

<div id="sidebar">
  <select id="lang-select" onchange="changeLanguage(this.value)">
    <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª</option>
    <option value="en">ğŸ‡ºğŸ‡¸ English</option>
    <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡ (ç®€ä½“)</option>
    <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
    <option value="pt">ğŸ‡§ğŸ‡· PortuguÃªs</option>
    <option value="ko">ğŸ‡°ğŸ‡· í•œêµ­ì–´</option>
  </select>

  <div id="user-chips-area">
    <div class="cat-title" data-i18n="cat_user_chips">ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ãƒãƒƒãƒ— (IC)</div>
    <div id="user-chips-list"></div>
  </div>

  <div class="cat-title" data-i18n="cat_ic_parts">ICä½œæˆç”¨ãƒ‘ãƒ¼ãƒ„</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'PinIn')" onclick="addPart('PinIn')"><span class="icon">ğŸ“¥</span> <span data-i18n="part_pin_in">å…¥åŠ›ãƒ”ãƒ³ (Pin In)</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'PinOut')" onclick="addPart('PinOut')"><span class="icon">ğŸ“¤</span> <span data-i18n="part_pin_out">å‡ºåŠ›ãƒ”ãƒ³ (Pin Out)</span></div>

  <div class="cat-title" data-i18n="cat_input">å…¥åŠ› (INPUT)</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Switch')" onclick="addPart('Switch')"><span class="icon">ğŸ”Œ</span> <span data-i18n="part_switch">ã‚¹ã‚¤ãƒƒãƒ</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Button')" onclick="addPart('Button')"><span class="icon">ğŸ”´</span> <span data-i18n="part_button">ãƒœã‚¿ãƒ³</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'KeyInput')" onclick="addPart('KeyInput')"><span class="icon">âŒ¨ï¸</span> <span data-i18n="part_key">ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Clock')" onclick="addPart('Clock')"><span class="icon">â°</span> <span data-i18n="part_clock">ã‚¯ãƒ­ãƒƒã‚¯</span></div>

  <div class="cat-title" data-i18n="cat_output">å‡ºåŠ› (OUTPUT)</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'LED')" onclick="addPart('LED')"><span class="icon">ğŸ’¡</span> <span data-i18n="part_led">LEDãƒ©ãƒ³ãƒ—</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'ColorLED')" onclick="addPart('ColorLED')"><span class="icon">ğŸŒˆ</span> <span data-i18n="part_color_led">ã‚«ãƒ©ãƒ¼LED</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'HexDisp')" onclick="addPart('HexDisp')"><span class="icon">8ï¸âƒ£</span> <span data-i18n="part_hex">7ã‚»ã‚° (16é€²)</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Buzzer')" onclick="addPart('Buzzer')"><span class="icon">ğŸ”Š</span> <span data-i18n="part_buzzer">ãƒ–ã‚¶ãƒ¼</span></div>

  <div class="cat-title" data-i18n="cat_gates">è«–ç†ã‚²ãƒ¼ãƒˆ (GATES)</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'AND')" onclick="addPart('AND')"><span class="icon">ï¼†</span> AND</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'OR')" onclick="addPart('OR')"><span class="icon">âˆ¥</span> OR</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'NOT')" onclick="addPart('NOT')"><span class="icon">â—</span> NOT</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'NAND')" onclick="addPart('NAND')"><span class="icon">âš¡</span> NAND</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'XOR')" onclick="addPart('XOR')"><span class="icon">âŒ</span> XOR</div>

  <div class="cat-title" data-i18n="cat_memory">ãƒ¡ãƒ¢ãƒª / CPU</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'D-FF')" onclick="addPart('D-FF')"><span class="icon">ğŸ“¦</span> <span data-i18n="part_dff">Dãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'JK-FF')" onclick="addPart('JK-FF')"><span class="icon">ğŸ”„</span> <span data-i18n="part_jkff">JKãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'RAM')" onclick="addPart('RAM')"><span class="icon">ğŸ’¾</span> <span data-i18n="part_ram">RAM (4bit x 16)</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'ROM')" onclick="addPart('ROM')"><span class="icon">ğŸ’¿</span> <span data-i18n="part_rom">ROM (4bit x 16)</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Counter')" onclick="addPart('Counter')"><span class="icon">ğŸ”¢</span> <span data-i18n="part_counter">4bit ã‚«ã‚¦ãƒ³ã‚¿</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Decoder')" onclick="addPart('Decoder')"><span class="icon">ğŸ“¶</span> <span data-i18n="part_decoder">ãƒ‡ã‚³ãƒ¼ãƒ€ (3to8)</span></div>

  <div class="cat-title" data-i18n="cat_other">ãã®ä»–</div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Matrix')" onclick="addPart('Matrix')"><span class="icon">â–¦</span> <span data-i18n="part_matrix">ãƒãƒˆãƒªã‚¯ã‚¹LED</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'ColorMatrix')" onclick="addPart('ColorMatrix')"><span class="icon">ğŸ³ï¸â€ğŸŒˆ</span> <span data-i18n="part_color_matrix">ã‚«ãƒ©ãƒ¼ãƒãƒˆãƒªã‚¯ã‚¹</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Delay')" onclick="addPart('Delay')"><span class="icon">â³</span> <span data-i18n="part_delay">é…å»¶ (Delay)</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Joint')" onclick="addPart('Joint')"><span class="icon">ğŸ”—</span> <span data-i18n="part_joint">ä¸­ç¶™ç‚¹ (Joint)</span></div>
  <div class="tool-btn" draggable="true" ondragstart="drag(event, 'Label')" onclick="addPart('Label')"><span class="icon">ğŸ·ï¸</span> <span data-i18n="part_label">ãƒ©ãƒ™ãƒ«</span></div>

  <!-- é€Ÿåº¦èª¿æ•´ã‚¨ãƒªã‚¢ (è¿½åŠ ) -->
  <div class="cat-title" data-i18n="cat_speed">ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é€Ÿåº¦</div>
  <div class="speed-control">
    <input id="speed-slider" type="range" min="1" max="5000" value="1" step="1" oninput="changeSpeed(this.value)">
    <div style="text-align:center">x <span id="speed-val">1</span></div>
  </div>

  <div class="tools-area">
    <div class="cat-title">UIè¨­å®š</div>
    <button class="action-btn btn-side" onclick="toggleSidebar()"><span data-i18n="btn_side_toggle">â†” ã‚µã‚¤ãƒ‰ãƒãƒ¼å·¦å³åˆ‡æ›¿</span></button>

    <button class="action-btn btn-create" onclick="createCustomChip()"><span data-i18n="btn_create_ic">âš¡ é¸æŠç¯„å›²ã‚’ICåŒ–</span></button>
    <div class="action-row">
      <button id="btn-ptr" class="action-btn btn-mode active" onclick="setMode('pointer')"><span data-i18n="btn_mode_ptr">ğŸ‘† æ“ä½œ</span></button>
      <button id="btn-pan" class="action-btn btn-mode" onclick="setMode('pan')"><span data-i18n="btn_mode_pan">âœ‹ ç§»å‹•</span></button>
      <button id="btn-sel" class="action-btn btn-mode" onclick="setMode('select')"><span data-i18n="btn_mode_sel">â› é¸æŠ</span></button>
    </div>
    <button class="action-btn btn-io" onclick="openIO()"><span data-i18n="btn_share">ğŸ“‹ ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿å…±æœ‰</span></button>
    <div class="action-row">
      <button class="action-btn btn-save" onclick="saveFile()"><span data-i18n="btn_save">ğŸ’¾ ä¿å­˜</span></button>
      <button class="action-btn btn-save" onclick="document.getElementById('file-input').click()"><span data-i18n="btn_open">ğŸ“‚ é–‹ã</span></button>
    </div>
  <button class="action-btn btn-clear" onclick="clearAll()"><span data-i18n="btn_clear">ğŸ—‘ å…¨æ¶ˆå»</span></button>
    
    <!-- ã‚¢ã‚¯ã‚»ã‚¹ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ (Views) -->
    <div style="margin-top: 15px; text-align: center; padding-bottom: 10px;">
      <span style="font-size:12px; color:#aaa; margin-right:5px;">Total Views:</span>
      <img src="https://visitor-badge.laobi.icu/badge?page_id=hiyodori14106.web-logic-simulator" alt="Visitor Count" style="vertical-align: middle;">
    </div>

  </div> <!-- tools-areaã®çµ‚ã‚ã‚Š -->
</div> <!-- sidebarã®çµ‚ã‚ã‚Š -->

<div id="canvas-container">
  <div id="scroll-spacer"></div>
  <canvas id="circuitCanvas" tabindex="0"></canvas>
  <div id="status-bar">
    <span id="status-text">Ready</span>
    <span>Ctrl+Z:Undo / Ctrl+C:Copy / Ctrl+V:Paste</span>
  </div>
</div>

<div id="io-modal">
  <div class="modal-content">
    <h3 data-i18n="modal_title">å›è·¯ãƒ‡ãƒ¼ã‚¿ (JSON)</h3>
    <textarea id="io-text" placeholder="ã“ã“ã«JSONãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘..."></textarea>
    <div class="modal-btns">
      <button class="action-btn btn-save" onclick="closeIO()"><span data-i18n="btn_close">é–‰ã˜ã‚‹</span></button>
      <button class="action-btn btn-save" onclick="copyIO()"><span data-i18n="btn_copy">ã‚³ãƒ”ãƒ¼</span></button>
      <button class="action-btn btn-reset" onclick="loadFromText()"><span data-i18n="btn_load">èª­è¾¼å®Ÿè¡Œ</span></button>
    </div>
  </div>
</div>

<input type="file" id="file-input" accept=".json" onchange="loadFile(this)">

<script>
// --- å¤šè¨€èªè¨­å®š (Multilingual) ---
const TRANSLATIONS = {
  ja: {
    cat_user_chips: "ãƒ¦ãƒ¼ã‚¶ãƒ¼å®šç¾©ãƒãƒƒãƒ— (IC)", cat_ic_parts: "ICä½œæˆç”¨ãƒ‘ãƒ¼ãƒ„", cat_input: "å…¥åŠ› (INPUT)", cat_output: "å‡ºåŠ› (OUTPUT)", cat_gates: "è«–ç†ã‚²ãƒ¼ãƒˆ (GATES)", cat_memory: "ãƒ¡ãƒ¢ãƒª / CPU", cat_other: "ãã®ä»–",
    cat_speed: "ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³é€Ÿåº¦", btn_side_toggle: "â†” ã‚µã‚¤ãƒ‰ãƒãƒ¼å·¦å³åˆ‡æ›¿",
    part_pin_in: "å…¥åŠ›ãƒ”ãƒ³ (Pin In)", part_pin_out: "å‡ºåŠ›ãƒ”ãƒ³ (Pin Out)", part_switch: "ã‚¹ã‚¤ãƒƒãƒ", part_button: "ãƒœã‚¿ãƒ³", part_key: "ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›", part_clock: "ã‚¯ãƒ­ãƒƒã‚¯",
    part_led: "LEDãƒ©ãƒ³ãƒ—", part_color_led: "ã‚«ãƒ©ãƒ¼LED", part_hex: "7ã‚»ã‚° (16é€²)", part_buzzer: "ãƒ–ã‚¶ãƒ¼",
    part_dff: "Dãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—", part_jkff: "JKãƒ•ãƒªãƒƒãƒ—ãƒ•ãƒ­ãƒƒãƒ—", part_ram: "RAM (4bit x 16)", part_rom: "ROM (4bit x 16)", part_counter: "4bit ã‚«ã‚¦ãƒ³ã‚¿", part_decoder: "ãƒ‡ã‚³ãƒ¼ãƒ€ (3to8)",
    part_matrix: "ãƒãƒˆãƒªã‚¯ã‚¹LED", part_color_matrix: "ã‚«ãƒ©ãƒ¼ãƒãƒˆãƒªã‚¯ã‚¹", part_delay: "é…å»¶ (Delay)", part_joint: "ä¸­ç¶™ç‚¹ (Joint)", part_label: "ãƒ©ãƒ™ãƒ«",
    btn_create_ic: "âš¡ é¸æŠç¯„å›²ã‚’ICåŒ–", btn_mode_ptr: "ğŸ‘† æ“ä½œ", btn_mode_pan: "âœ‹ ç§»å‹•", btn_mode_sel: "â› é¸æŠ",
    btn_share: "ğŸ“‹ ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿å…±æœ‰", btn_save: "ğŸ’¾ ä¿å­˜", btn_open: "ğŸ“‚ é–‹ã", btn_clear: "ğŸ—‘ å…¨æ¶ˆå»",
    modal_title: "å›è·¯ãƒ‡ãƒ¼ã‚¿ (JSON)", btn_close: "é–‰ã˜ã‚‹", btn_copy: "ã‚³ãƒ”ãƒ¼", btn_load: "èª­è¾¼å®Ÿè¡Œ",
    placeholder_json: "ã“ã“ã«JSONãƒ‡ãƒ¼ã‚¿ã‚’è²¼ã‚Šä»˜ã‘...", default_text: "ãƒ†ã‚­ã‚¹ãƒˆ",
    prompt_rom: "ROMãƒ‡ãƒ¼ã‚¿ (16é€²æ•° 16å€‹ ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Š):", prompt_key: "å‰²å½“ã‚­ãƒ¼:", confirm_toggle: "ãƒˆã‚°ãƒ«ãƒ¢ãƒ¼ãƒ‰ã«ã—ã¾ã™ã‹?",
    prompt_digits: "æ¡æ•° (1-8):", prompt_rows: "è¡Œæ•° (Rows):", prompt_cols: "åˆ—æ•° (Cols):", prompt_size: "å…¨ä½“ã®å¹…(px)ã‚’è¨­å®š (ç©ºæ¬„ã§è‡ªå‹•: $px ã«ãƒªã‚µã‚¤ã‚º)", prompt_label: "ãƒ©ãƒ™ãƒ« / å€¤:",
    alert_select_chip: "ãƒãƒƒãƒ—åŒ–ã™ã‚‹éƒ¨å“ã‚’é¸æŠã—ã¦ãã ã•ã„", prompt_chip_name: "ãƒãƒƒãƒ—åã‚’å…¥åŠ›:", confirm_no_pins: "å…¥å‡ºåŠ›ãƒ”ãƒ³ãŒå«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ",
    status_ic_created: "ICãƒãƒƒãƒ— [$] ã‚’ä½œæˆã—ã¾ã—ãŸ", status_placed: "$ ã‚’é…ç½®ã—ã¾ã—ãŸ", alert_copied: "ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ", alert_invalid: "ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹ã§ã™", confirm_clear: "æœ¬å½“ã«å…¨ã¦æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ",
  },
  en: {
    cat_user_chips: "User Chips (IC)", cat_ic_parts: "IC Parts", cat_input: "Input (INPUT)", cat_output: "Output (OUTPUT)", cat_gates: "Logic Gates (GATES)", cat_memory: "Memory / CPU", cat_other: "Others",
    cat_speed: "Simulation Speed", btn_side_toggle: "â†” Sidebar Left/Right",
    part_pin_in: "Pin In", part_pin_out: "Pin Out", part_switch: "Switch", part_button: "Button", part_key: "Keyboard Input", part_clock: "Clock",
    part_led: "LED Lamp", part_color_led: "Color LED", part_hex: "7-Seg (Hex)", part_buzzer: "Buzzer",
    part_dff: "D Flip-Flop", part_jkff: "JK Flip-Flop", part_ram: "RAM (4bit x 16)", part_rom: "ROM (4bit x 16)", part_counter: "4bit Counter", part_decoder: "Decoder (3to8)",
    part_matrix: "Matrix LED", part_color_matrix: "Color Matrix", part_delay: "Delay", part_joint: "Joint", part_label: "Label",
    btn_create_ic: "âš¡ Create IC from Sel", btn_mode_ptr: "ğŸ‘† Interact", btn_mode_pan: "âœ‹ Pan", btn_mode_sel: "â› Select",
    btn_share: "ğŸ“‹ Share Text Data", btn_save: "ğŸ’¾ Save", btn_open: "ğŸ“‚ Open", btn_clear: "ğŸ—‘ Clear All",
    modal_title: "Circuit Data (JSON)", btn_close: "Close", btn_copy: "Copy", btn_load: "Load",
    placeholder_json: "Paste JSON data here...", default_text: "Text",
    prompt_rom: "ROM Data (16 Hex values separated by space):", prompt_key: "Assign Key:", confirm_toggle: "Enable Toggle Mode?",
    prompt_digits: "Digits (1-8):", prompt_rows: "Rows:", prompt_cols: "Cols:", prompt_size: "Total Width (px) (Empty for auto: $px)", prompt_label: "Label / Value:",
    alert_select_chip: "Please select parts to convert to IC.", prompt_chip_name: "Enter Chip Name:", confirm_no_pins: "No input/output pins selected. Continue?",
    status_ic_created: "IC Chip [$] created.", status_placed: "Placed $", alert_copied: "Copied to clipboard.", alert_invalid: "Invalid Data.", confirm_clear: "Are you sure you want to clear all?",
  },
  zh: {
    cat_user_chips: "ç”¨æˆ·èŠ¯ç‰‡ (IC)", cat_ic_parts: "IC ç»„ä»¶", cat_input: "è¾“å…¥ (INPUT)", cat_output: "è¾“å‡º (OUTPUT)", cat_gates: "é€»è¾‘é—¨ (GATES)", cat_memory: "å­˜å‚¨å™¨ / CPU", cat_other: "å…¶ä»–",
    cat_speed: "æ¨¡æ‹Ÿé€Ÿåº¦", btn_side_toggle: "â†” åˆ‡æ¢ä¾§è¾¹æ ä½ç½®",
    part_pin_in: "è¾“å…¥å¼•è„š (Pin In)", part_pin_out: "è¾“å‡ºå¼•è„š (Pin Out)", part_switch: "å¼€å…³", part_button: "æŒ‰é’®", part_key: "é”®ç›˜è¾“å…¥", part_clock: "æ—¶é’Ÿ",
    part_led: "LED ç¯", part_color_led: "å½©è‰² LED", part_hex: "7æ®µæ•°ç ç®¡ (16è¿›åˆ¶)", part_buzzer: "èœ‚é¸£å™¨",
    part_dff: "D è§¦å‘å™¨", part_jkff: "JK è§¦å‘å™¨", part_ram: "RAM (4bit x 16)", part_rom: "ROM (4bit x 16)", part_counter: "4ä½è®¡æ•°å™¨", part_decoder: "è¯‘ç å™¨ (3to8)",
    part_matrix: "ç‚¹é˜µ LED", part_color_matrix: "å½©è‰²ç‚¹é˜µ", part_delay: "å»¶è¿Ÿ (Delay)", part_joint: "è¿æ¥ç‚¹ (Joint)", part_label: "æ ‡ç­¾",
    btn_create_ic: "âš¡ é€‰åŒºè½¬ IC", btn_mode_ptr: "ğŸ‘† æ“ä½œ", btn_mode_pan: "âœ‹ ç§»åŠ¨", btn_mode_sel: "â› é€‰æ‹©",
    btn_share: "ğŸ“‹ åˆ†äº«æ–‡æœ¬æ•°æ®", btn_save: "ğŸ’¾ ä¿å­˜", btn_open: "ğŸ“‚ æ‰“å¼€", btn_clear: "ğŸ—‘ æ¸…ç©º",
    modal_title: "ç”µè·¯æ•°æ® (JSON)", btn_close: "å…³é—­", btn_copy: "å¤åˆ¶", btn_load: "åŠ è½½",
    placeholder_json: "åœ¨æ­¤ç²˜è´´ JSON ãƒ‡ãƒ¼ã‚¿...", default_text: "æ–‡æœ¬",
    prompt_rom: "ROM ãƒ‡ãƒ¼ã‚¿ (16ä¸ª16è¿›åˆ¶æ•°ï¼Œç©ºæ ¼åˆ†éš”):", prompt_key: "åˆ†é…æŒ‰é”®:", confirm_toggle: "å¯ç”¨åˆ‡æ¢æ¨¡å¼å—?",
    prompt_digits: "ä½æ•° (1-8):", prompt_rows: "è¡Œæ•°:", prompt_cols: "åˆ—æ•°:", prompt_size: "æ€»å®½åº¦(px) (ç•™ç©ºè‡ªåŠ¨: $px)", prompt_label: "æ ‡ç­¾ / å€¼:",
    alert_select_chip: "è¯·é€‰æ‹©è¦è½¬æ¢ä¸º IC çš„å…ƒä»¶ã€‚", prompt_chip_name: "è¾“å…¥èŠ¯ç‰‡åç§°:", confirm_no_pins: "æœªé€‰æ‹©è¾“å…¥/è¾“å‡ºå¼•è„šã€‚ç»§ç»­å—ï¼Ÿ",
    status_ic_created: "IC èŠ¯ç‰‡ [$] å·²åˆ›å»ºã€‚", status_placed: "å·²æ”¾ç½® $", alert_copied: "å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚", alert_invalid: "æ•°æ®æ— æ•ˆã€‚", confirm_clear: "ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å†…å®¹å—ï¼Ÿ",
  }
};

let currentLang = 'ja';
const navLang = navigator.language.slice(0,2);
if(TRANSLATIONS[navLang]) currentLang = navLang;

function txt(key, replacement) {
  let str = TRANSLATIONS[currentLang][key] || TRANSLATIONS['en'][key] || key;
  if (replacement !== undefined) str = str.replace('$', replacement);
  return str;
}

function toggleSidebar() {
  document.body.classList.toggle('sidebar-right');
}

function changeLanguage(lang) {
  currentLang = lang;
  updateUIText();
}

function updateUIText() {
  document.querySelectorAll('[data-i18n]').forEach(el => {
    const k = el.getAttribute('data-i18n');
    if (el.querySelector('.icon')) {
        const iconHTML = el.querySelector('.icon').outerHTML;
        el.innerHTML = iconHTML + " " + txt(k);
    } else {
        el.innerText = txt(k);
    }
  });
  document.getElementById('io-text').placeholder = txt('placeholder_json');
  document.getElementById('lang-select').value = currentLang;
}

// --- åˆæœŸåŒ– ---
const canvas = document.getElementById('circuitCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');
const spacer = document.getElementById('scroll-spacer');
const statusEl = document.getElementById('status-text');
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const modal = document.getElementById('io-modal');
const ioText = document.getElementById('io-text');

let loopsPerFrame = 1; 
function changeSpeed(val) {
  loopsPerFrame = parseInt(val);
  document.getElementById('speed-val').innerText = val;
}

const GRID = 20;
const COLORS = { text: '#fff', select: '#00e5ff', wireOn: '#76ff03', wireOff: '#555', pin: '#999', pinActive: '#76ff03', chip: '#37474f' };
const WIRE_COLORS = [null, '#ff2222', '#2288ff', '#ffff00', '#ff00ff', '#ffffff'];

const WORLD_SIZE = 10000;
const OFFSET_BASE = WORLD_SIZE / 2;
let view = { x: -OFFSET_BASE, y: -OFFSET_BASE, scale: 1.0 };
let width, height;
let parts = [];
let wires = [];
let selectedParts = [];
let selectedWires = [];
let customDefs = {};
const MAX_HISTORY = 50;
let history = [];
let historyIndex = -1;
let isUndoRedo = false;

let mode = 'pointer';
const STATE = { IDLE:0, DRAGGING:1, WIRING:2, SELECTING:3, PANNING:4 };
let state = STATE.IDLE;
let mouse = { x: 0, y: 0, downX: 0, downY: 0, dragStartX: 0, dragStartY: 0, downPart: null };
let dragOffsets = new Map();
let tempWire = null;
let targetPort = null;
let clipboard = null;
let isSpacePressed = false;
let hasDraggedPart = false;
let globalTick = 0;

// ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ã¨ã®åŒæœŸãƒ­ã‚¸ãƒƒã‚¯
function syncScrollToView() {
  container.scrollLeft = OFFSET_BASE + view.x;
  container.scrollTop = OFFSET_BASE + view.y;
}

container.onscroll = (e) => {
  if (state !== STATE.PANNING && state !== STATE.DRAGGING) {
    view.x = container.scrollLeft - OFFSET_BASE;
    view.y = container.scrollTop - OFFSET_BASE;
  }
};

function toWorld(sx, sy) { 
  return { x: (sx + view.x) / view.scale, y: (sy + view.y) / view.scale }; 
}
function snap(v) { return Math.round(v/GRID)*GRID; }

const STD_DEF = {
  'Switch': { w:40, h:30, in:0, out:1, color:'#455a64', label:'SW' },
  'Button': { w:40, h:30, in:0, out:1, color:'#b71c1c', label:'BTN' },
  'KeyInput': { w:60, h:30, in:0, out:1, color:'#d32f2f', label:'KEY' },
  'Clock': { w:40, h:30, in:0, out:1, color:'#00695c', label:'CLK' },
  'PinIn': { w:30, h:30, in:0, out:1, color:'#f57f17', label:'IN' },
  'PinOut': { w:30, h:30, in:1, out:0, color:'#fbc02d', label:'OUT' },
  'LED': { w:30, h:30, in:1, out:0, color:'#263238', label:'LED' },
  'ColorLED': { w:40, h:40, in:3, out:0, color:'#263238', label:'RGB' },
  'Buzzer': { w:40, h:40, in:1, out:0, color:'#3e2723', label:'Bz' },
  'HexDisp': { w:50, h:70, in:4, out:0, color:'#212121', label:'' },
  'Matrix': { w:100, h:100, in:16, out:0, color:'#000', label:'' },
  'ColorMatrix':{ w:120, h:100, in:32, out:0, color:'#000', label:'' },
  'AND': { w:50, h:35, in:2, out:1, color:'#1565c0', label:'AND' },
  'OR': { w:50, h:35, in:2, out:1, color:'#7b1fa2', label:'OR' },
  'NOT': { w:50, h:35, in:1, out:1, color:'#ad1457', label:'NOT' },
  'NAND': { w:50, h:35, in:2, out:1, color:'#e65100', label:'NAND' },
  'XOR': { w:50, h:35, in:2, out:1, color:'#4527a0', label:'XOR' },
  'D-FF': { w:50, h:50, in:2, out:2, color:'#00838f', label:'D-FF' },
  'JK-FF': { w:50, h:70, in:3, out:2, color:'#00838f', label:'JK-FF' },
  'SR-FF': { w:50, h:70, in:3, out:2, color:'#00838f', label:'SR-FF' },
  'Counter': { w:60, h:50, in:2, out:4, color:'#4a148c', label:'CNT' },
  'Decoder': { w:50, h:100, in:3, out:8, color:'#33691e', label:'DEC' },
  'RAM': { w:100, h:120, in:10, out:4, color:'#37474f', label:'RAM' },
  'ROM': { w:100, h:100, in:4, out:4, color:'#37474f', label:'ROM' },
  'Delay': { w:40, h:30, in:1, out:1, color:'#5e35b1', label:'DLY' },
  'Joint': { w:20, h:20, in:1, out:1, color:'#9e9e9e', label:'' },
  'Label': { w:100, h:20, in:0, out:0, color:'transparent', label:'Text' }
};

class Part {
  constructor(type, x, y) {
    this.id = 'p_' + Date.now() + '_' + Math.floor(Math.random()*100000);
    this.type = type;
    this.x = snap(x);
    this.y = snap(y);
    
    if (customDefs[type]) {
      this.isCustom = true;
      this.def = customDefs[type];
      this.internalState = this.initCustomState(this.def);
    } else {
      this.isCustom = false;
      this.def = Object.assign({}, STD_DEF[type] || {w:40, h:40, in:0, out:0, color:'#555'});
    }
    this.w = this.def.w;
    this.h = this.def.h;
    this.label = this.def.label || type;
    if(type==='Joint') this.label = '';

    if (type === 'HexDisp') { this.digits = 1; }
    if (type === 'Matrix' || type === 'ColorMatrix') { this.rows = 8; this.cols = 8; this.gridState = null; }

    this.inputs = new Array(this.def.in).fill(false);
    this.outputs = new Array(this.def.out).fill(false);
    this.active = false;
    this.value = 0;

    if (type==='Clock') { this.interval=10; this.lastToggle=0; }
    if (type==='KeyInput') { this.assignedKey='a'; this.isToggleMode=false; this.isKeyPressed=false; }
    if (['D-FF','JK-FF','SR-FF','Counter'].includes(type) || type==='RAM') { this.state=false; this.lastClk=false; }
    if (type==='RAM') { this.data=new Array(16).fill(0); }
    if (type==='ROM') { this.data=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]; }
    if (type==='Delay') { this.delayTime=100; this.queue=[]; this.lastInput=false; }
    if (type==='Buzzer') { this.freq=440; }
    if (type==='Label') { this.label=txt('default_text'); }
  }

  initCustomState(def) {
    const map = {};
    const parts = def.parts.map(p => {
      const np = new Part(p.type, 0, 0);
      Object.assign(np, p);
      np.inputs = new Array(np.def.in).fill(false);
      np.outputs = new Array(np.def.out).fill(false);
      if(np.type==='RAM') np.data = new Array(16).fill(0);
      map[p.id] = np;
      return np;
    });
    const wires = def.wires.map(w => ({
      source: map[w.srcId],
      sourceIdx: w.srcIdx,
      target: map[w.tgtId],
      targetIdx: w.tgtIdx
    })).filter(w => w.source && w.target);

    const inPins = parts.filter(p => p.type==='PinIn').sort((a,b)=>a.y-b.y);
    const outPins = parts.filter(p => p.type==='PinOut').sort((a,b)=>a.y-b.y);
    return { parts, wires, inPins, outPins };
  }

  update(tick) {
    for(let i=0; i<this.inputs.length; i++) {
      const w = wires.find(w => w.target === this && w.targetIdx === i);
      this.inputs[i] = w ? w.source.outputs[w.sourceIdx] : false;
    }
    if(this.isCustom) this.updateCustom(tick);
    else this.updateStandard(tick);
  }

  updateCustom(tick) {
    const S = this.internalState;
    for(let i=0; i<this.inputs.length; i++) {
      if(S.inPins[i]) {
        S.inPins[i].outputs[0] = this.inputs[i];
        S.inPins[i].active = this.inputs[i];
      }
    }
    S.parts.forEach(p => p.updateInternal(S.wires, tick));
    for(let i=0; i<this.outputs.length; i++) {
      if(S.outPins[i]) {
        this.outputs[i] = S.outPins[i].inputs[0];
      }
    }
  }

  updateInternal(localWires, tick) {
    for(let i=0; i<this.def.in; i++) {
      const w = localWires.find(w => w.target === this && w.targetIdx === i);
      this.inputs[i] = w ? w.source.outputs[w.sourceIdx] : false;
    }
    if(this.isCustom) this.updateCustom(tick);
    else this.updateStandard(tick);
  }

  updateStandard(tick) {
    const ins = this.inputs;
    switch(this.type) {
      case 'Switch': case 'Button': case 'KeyInput': case 'PinIn': case 'PinOut': case 'Label': break;
      case 'Joint': this.outputs[0] = ins[0]; break;
      case 'Clock': 
        if(tick - this.lastToggle >= (this.interval || 1)) {
          this.active = !this.active;
          this.lastToggle = tick;
        }
        this.outputs[0]=this.active;
        break;
      case 'AND': this.outputs[0] = ins[0] && ins[1]; break;
      case 'OR':  this.outputs[0] = ins[0] || ins[1]; break;
      case 'NOT': this.outputs[0] = !ins[0]; break;
      case 'NAND':this.outputs[0] = !(ins[0] && ins[1]); break;
      case 'XOR': this.outputs[0] = (ins[0] !== ins[1]); break;
      case 'LED': this.active = ins[0]; break;
      case 'ColorLED': this.active = ins[0]||ins[1]||ins[2]; break;
      case 'Buzzer': this.active = ins[0]; this.updateAudio(); break;
      case 'Delay': {
        if(ins[0]!==this.lastInput){
          this.queue.push({v:ins[0], t:tick+this.delayTime});
          this.lastInput=ins[0];
        }
        while(this.queue.length>0 && tick>=this.queue[0].t) {
          this.active=this.queue.shift().v;
        }
        this.outputs[0]=this.active;
        break;
      }
      case 'D-FF':
        if(!this.lastClk && ins[1]) { this.state=ins[0]; }
        this.lastClk=ins[1];
        this.outputs[0]=this.state; this.outputs[1]=!this.state;
        break;
      case 'JK-FF':
        if(!this.lastClk && ins[2]) {
          if(ins[0]&&!ins[1]) this.state=true;
          else if(!ins[0]&&ins[1]) this.state=false;
          else if(ins[0]&&ins[1]) this.state=!this.state;
        }
        this.lastClk=ins[2];
        this.outputs[0]=this.state; this.outputs[1]=!this.state;
        break;
      case 'SR-FF':
        if(!this.lastClk && ins[2]) {
            if(ins[0]) this.state=true;
            else if(ins[1]) this.state=false;
        }
        this.lastClk=ins[2];
        this.outputs[0]=this.state; this.outputs[1]=!this.state;
        break;
      case 'Counter':
        if(ins[1]) this.value=0;
        else if(!this.lastClk && ins[0]) this.value=(this.value+1)%16;
        this.lastClk=ins[0];
        this.outputs[0]=(this.value&1)!=0;
        this.outputs[1]=(this.value&2)!=0;
        this.outputs[2]=(this.value&4)!=0;
        this.outputs[3]=(this.value&8)!=0;
        break;
      case 'Decoder': {
        const a=(ins[0]?1:0)+(ins[1]?2:0)+(ins[2]?4:0);
        for(let i=0;i<8;i++) this.outputs[i]=(i===a);
        break;
      }
      case 'RAM': {
        const wd=(ins[0]?1:0)+(ins[1]?2:0)+(ins[2]?4:0)+(ins[3]?8:0);
        const wa=(ins[4]?1:0)+(ins[5]?2:0)+(ins[6]?4:0)+(ins[7]?8:0);
        if(!this.lastClk && ins[9] && ins[8]) this.data[wa]=wd;
        this.lastClk=ins[9];
        const rv=this.data[wa];
        this.outputs[0]=(rv&1)!=0;
        this.outputs[1]=(rv&2)!=0;
        this.outputs[2]=(rv&4)!=0;
        this.outputs[3]=(rv&8)!=0;
        break;
      }
      case 'ROM': {
        const ra=(ins[0]?1:0)+(ins[1]?2:0)+(ins[2]?4:0)+(ins[3]?8:0);
        const ro=this.data[ra]||0;
        this.outputs[0]=(ro&1)!=0;
        this.outputs[1]=(ro&2)!=0;
        this.outputs[2]=(ro&4)!=0;
        this.outputs[3]=(ro&8)!=0;
        break;
      }
      case 'HexDisp': break;
      case 'Matrix': case 'ColorMatrix': {
        const totalPixels = this.rows * this.cols;
        if (!this.gridState || this.gridState.length !== totalPixels) {
          if(this.type === 'Matrix') this.gridState = new Array(totalPixels).fill(0);
          else this.gridState = new Array(totalPixels).fill(null).map(()=>({r:0,g:0,b:0}));
        }
        if (this.type === 'Matrix') {
          for(let r=0; r<this.rows; r++) {
            if (this.inputs[r]) {
              for(let c=0; c<this.cols; c++) {
                if (this.inputs[this.rows + c]) {
                  this.gridState[r*this.cols + c] = 1.0;
                }
              }
            }
          }
        } else {
            const startR = this.rows;
            const startG = this.rows + this.cols;
            const startB = this.rows + this.cols * 2;
            for(let r=0; r<this.rows; r++) {
                if (this.inputs[r]) {
                    for(let c=0; c<this.cols; c++) {
                        const idx = r*this.cols + c;
                        if(this.inputs[startR + c]) this.gridState[idx].r = 1.0;
                        if(this.inputs[startG + c]) this.gridState[idx].g = 1.0;
                        if(this.inputs[startB + c]) this.gridState[idx].b = 1.0;
                    }
                }
            }
        }
        break;
      }
    }
    if(['AND','OR','NOT','NAND','XOR'].includes(this.type)) this.active=this.outputs[0];
    if(['Switch','Button','KeyInput','PinIn'].includes(this.type)) this.outputs[0]=this.active;
  }

  updateAudio() {
    if(this.active) {
      if(!this.oscillator) {
        this.oscillator=audioCtx.createOscillator();
        this.gainNode=audioCtx.createGain();
        this.oscillator.type='square';
        this.oscillator.frequency.setValueAtTime(this.freq,audioCtx.currentTime);
        this.gainNode.gain.value=0.05;
        this.oscillator.connect(this.gainNode);
        this.gainNode.connect(audioCtx.destination);
        this.oscillator.start();
      }
    } else {
      if(this.oscillator){
        this.oscillator.stop();
        this.oscillator.disconnect();
        this.gainNode.disconnect();
        this.oscillator=null;
      }
    }
  }

  draw() {
    const isSel = selectedParts.includes(this);
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 3;

    if(this.type==='Label') {
      ctx.fillStyle = isSel ? 'rgba(255,255,255,0.1)' : 'transparent';
      ctx.strokeStyle = isSel ? COLORS.select : 'transparent';
      ctx.shadowColor = 'transparent';
    } else if(this.type==='Matrix' || this.type==='ColorMatrix') {
      ctx.fillStyle='#000';
      ctx.strokeStyle = isSel ? COLORS.select : '#333';
      const decay = 0.85;
      const total = (this.rows||8) * (this.cols||8);
      if(this.type==='Matrix') {
        for(let i=0;i<total;i++) this.gridState[i] *= decay;
      } else {
        for(let i=0;i<total;i++) {
          this.gridState[i].r *= decay;
          this.gridState[i].g *= decay;
          this.gridState[i].b *= decay;
        }
      }
    } else if(this.isCustom || this.type==='RAM' || this.type==='ROM') {
      ctx.fillStyle=this.def.color||'#333';
      ctx.strokeStyle = isSel ? COLORS.select : '#000';
    } else if(this.type==='Joint') {
      ctx.fillStyle = '#bbb';
      ctx.strokeStyle = isSel ? COLORS.select : '#555';
    } else {
      ctx.fillStyle = this.def.color;
      if((this.type==='Button' || this.type==='KeyInput') && this.active) ctx.fillStyle='#ff5252';
      ctx.strokeStyle = isSel ? COLORS.select : '#000';
    }

    if(this.type === 'Joint') {
      ctx.beginPath();
      ctx.arc(this.x+this.w/2, this.y+this.h/2, 6, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
    } else {
      ctx.beginPath();
      ctx.roundRect(this.x, this.y, this.w, this.h, 4);
      ctx.fill();
      ctx.shadowBlur=0; 
      ctx.shadowOffsetY=0;
      ctx.lineWidth = isSel ? 2 : 1;
      if(this.type!=='Label' || isSel) ctx.stroke();
    }

    ctx.fillStyle='#fff';
    ctx.textAlign='center';
    ctx.textBaseline='middle';

    if(this.isCustom || this.type==='RAM' || this.type==='ROM' || this.type==='D-FF') {
      ctx.font='bold 12px sans-serif';
      ctx.fillText(this.label, this.x+this.w/2, this.y+this.h/2);
      if(this.type==='RAM') {
        ctx.fillStyle='#aaa'; ctx.font='9px sans-serif';
        ctx.textAlign='left'; ctx.fillText('D', this.x+2, this.y+40); ctx.fillText('A', this.x+2, this.y+75); ctx.fillText('WE', this.x+2, this.y+110);
        ctx.textAlign='right'; ctx.fillText('Q', this.x+this.w-2, this.y+60);
      }
    } else if(this.type==='HexDisp') {
      const segsDat=[[1,1,1,1,1,1,0],[0,1,1,0,0,0,0],[1,1,0,1,1,0,1],[1,1,1,1,0,0,1],[0,1,1,0,0,1,1],[1,0,1,1,0,1,1],[1,0,1,1,1,1,1],[1,1,1,0,0,0,0],[1,1,1,1,1,1,1],[1,1,1,1,0,1,1],[1,1,1,0,1,1,1],[0,0,1,1,1,1,1],[1,0,0,1,1,1,0],[0,1,1,1,1,0,1],[1,0,0,1,1,1,1],[1,0,0,0,1,1,1]];
      const digits = this.digits || 1;
      const oneW = this.w / digits;
      for(let d=0; d<digits; d++) {
        const idx = d * 4;
        const val = (this.inputs[idx]?8:0)+(this.inputs[idx+1]?4:0)+(this.inputs[idx+2]?2:0)+(this.inputs[idx+3]?1:0);
        const segs = segsDat[val];
        const cx = this.x + this.w - (oneW/2) - (d * oneW);
        const cy = this.y + this.h/2;
        const s = Math.min(8, oneW/4);
        ctx.lineWidth=3; ctx.lineCap='round';
        const dl=(x1,y1,x2,y2,on)=>{ ctx.strokeStyle=on?'#f00':'#311'; ctx.beginPath();ctx.moveTo(cx+x1,cy+y1);ctx.lineTo(cx+x2,cy+y2);ctx.stroke();};
        dl(-s,-2*s,s,-2*s,segs[0]); dl(s,-2*s,s,0,segs[1]); dl(s,0,s,2*s,segs[2]);
        dl(-s,2*s,s,2*s,segs[3]); dl(-s,0,-s,2*s,segs[4]); dl(-s,-2*s,-s,0,segs[5]); dl(-s,0,s,0,segs[6]);
      }
    } else if(this.type==='Matrix') {
      const R = this.rows || 8;
      const C = this.cols || 8;
      const pad = 5;
      const rSize = (this.h - pad*2) / R;
      const cSize = (this.w - pad*2) / C;
      const rad = Math.min(rSize, cSize) * 0.35;
      const gs = this.gridState || new Array(R*C).fill(0);
      for(let y=0; y<R; y++) {
        for(let x=0; x<C; x++) {
          const val = gs[y*C + x];
          ctx.beginPath();
          ctx.arc(this.x + pad + x*cSize + cSize/2, this.y + pad + y*rSize + rSize/2, rad, 0, Math.PI*2);
          ctx.fillStyle = val > 0.1 ? `rgba(255,0,0,${Math.min(1, val)})` : '#311';
          ctx.fill();
        }
      }
    } else if(this.type==='ColorMatrix') {
      const R = this.rows || 8;
      const C = this.cols || 8;
      const pad = 5;
      const rSize = (this.h - pad*2) / R;
      const cSize = (this.w - pad*2) / C;
      const rad = Math.min(rSize, cSize) * 0.35;
      const gs = this.gridState || new Array(R*C).fill(0).map(()=>({r:0,g:0,b:0}));
      for(let y=0; y<R; y++) {
        for(let x=0; x<C; x++) {
          const p = gs[y*C + x];
          ctx.beginPath();
          ctx.arc(this.x + pad + x*cSize + cSize/2, this.y + pad + y*rSize + rSize/2, rad, 0, Math.PI*2);
          if (p && (p.r > 0.1 || p.g > 0.1 || p.b > 0.1)) {
            const r = Math.min(255, Math.floor(p.r*255));
            const g = Math.min(255, Math.floor(p.g*255));
            const b = Math.min(255, Math.floor(p.b*255));
            ctx.fillStyle = `rgb(${r},${g},${b})`;
          } else {
            ctx.fillStyle = '#111';
          }
          ctx.fill();
        }
      }
    } else if(this.type==='Label') {
      ctx.textAlign='left';ctx.font='14px sans-serif';ctx.fillText(this.label, this.x+5, this.y+10);
    } else if(this.type!=='Joint') {
      ctx.font='bold 11px sans-serif';
      let t = this.label;
      if(this.type==='KeyInput') t=`[${this.assignedKey.toUpperCase()}]`;
      if(view.scale>0.5) ctx.fillText(t, this.x+this.w/2, this.y+this.h/2);
    }

    if(this.type==='LED' && this.active) {
      ctx.fillStyle='#ffeb3b';
      ctx.beginPath(); ctx.arc(this.x+this.w/2, this.y+this.h/2, 10, 0, Math.PI*2); ctx.fill();
    }
    if(this.type==='ColorLED' && this.active) {
      const r=this.inputs[0]?255:0, g=this.inputs[1]?255:0, b=this.inputs[2]?255:0;
      ctx.fillStyle=`rgb(${r},${g},${b})`;
      ctx.beginPath(); ctx.arc(this.x+this.w/2, this.y+this.h/2, 12, 0, Math.PI*2); ctx.fill();
    }

    if(view.scale>0.3 && this.type!=='Label') {
      const drawP = (isIn, i) => {
        const pos = this.getPortPos(isIn, i);
        ctx.beginPath();ctx.arc(pos.x, pos.y, 3/view.scale, 0, Math.PI*2);
        const on = (isIn ? this.inputs[i] : this.outputs[i]);
        ctx.fillStyle = on ? COLORS.wireOn : COLORS.wireOff;
        if(this.type==='Joint') ctx.fillStyle = 'rgba(0,0,0,0)';
        ctx.fill();
      };
      for(let i=0; i<this.inputs.length; i++) drawP(true, i);
      for(let i=0; i<this.outputs.length; i++) drawP(false, i);
    }
    ctx.restore();
  }

  getPortPos(isInput, idx) {
    if(this.type==='Matrix' && isInput) {
      const R = this.rows || 8;
      const C = this.cols || 8;
      if(idx < R) {
        const step = this.h / (R + 1);
        return {x:this.x, y:this.y + step*(idx+1)};
      } else {
        const colIdx = idx - R;
        const step = this.w / (C + 1);
        return {x:this.x + step*(colIdx+1), y:this.y+this.h};
      }
    }
    if(this.type==='ColorMatrix' && isInput) {
        const R = this.rows || 8;
        const C = this.cols || 8;
        if(idx < R) {
            const step = this.h / (R + 1);
            return {x:this.x, y:this.y + step*(idx+1)};
        } else {
            const colTotalIdx = idx - R;
            const step = this.w / (3 * C + 1);
            return {x:this.x + step*(colTotalIdx+1), y:this.y+this.h};
        }
    }
    if(this.type==='Joint') return {x:this.x+this.w/2, y:this.y+this.h/2};
    const cnt = isInput ? this.inputs.length : this.outputs.length;
    if((this.isCustom || this.type==='RAM' || this.type==='ROM' || this.type==='HexDisp') && isInput) {
      const step = this.h/(cnt+1);
      return {x:this.x, y:this.y+step*(idx+1)};
    }
    const step = this.h/(cnt+1);
    return { x: isInput ? this.x : this.x+this.w, y: this.y + step*(idx+1) };
  }

  hitTest(x,y) { return x>=this.x && x<=this.x+this.w && y>=this.y && y<=this.y+this.h; }
}

function resize() {
  width=container.clientWidth;
  height=container.clientHeight;
  canvas.width=width;
  canvas.height=height;
}
window.onresize = resize;
resize();
syncScrollToView();

function loop() {
  for(let i=0; i<loopsPerFrame; i++) {
    globalTick++;
    parts.forEach(p => p.update(globalTick));
  }

  ctx.clearRect(0,0,width,height);
  ctx.save();
  ctx.translate(-view.x, -view.y);
  ctx.scale(view.scale, view.scale);

  const st = toWorld(0,0);
  const en = toWorld(width,height);
  const step = (view.scale < 0.5) ? GRID*2 : GRID;

  ctx.strokeStyle = '#2a2a2a';
  ctx.lineWidth = 1/view.scale;
  ctx.beginPath();
  for(let x=Math.floor(st.x/step)*step; x<en.x; x+=step) { ctx.moveTo(x,st.y); ctx.lineTo(x,en.y); }
  for(let y=Math.floor(st.y/step)*step; y<en.y; y+=step) { ctx.moveTo(st.x,y); ctx.lineTo(en.x,y); }
  ctx.stroke();

  wires.forEach(w => {
    const p1 = w.source.getPortPos(false, w.sourceIdx);
    if (w.targetIdx >= w.target.inputs.length) return;
    const p2 = w.target.getPortPos(true, w.targetIdx);
    const isActive = w.source.outputs[w.sourceIdx];
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.bezierCurveTo(p1.x+30, p1.y, p2.x-30, p2.y, p2.x, p2.y);
    if (selectedWires.includes(w)) {
      ctx.strokeStyle = '#00e5ff'; ctx.lineWidth = 4 / view.scale; ctx.stroke(); ctx.lineWidth = 2 / view.scale;
    }
    let color = isActive ? COLORS.wireOn : COLORS.wireOff;
    if(w.color) {
      if(isActive) color = w.color;
      else {
        const c = parseInt(w.color.slice(1), 16);
        const r=(c>>16)&255, g=(c>>8)&255, b=c&255;
        color = `rgb(${r*0.4},${g*0.4},${b*0.4})`;
      }
    }
    ctx.strokeStyle = color;
    ctx.lineWidth = 3 / Math.max(0.5, Math.min(1.5, view.scale));
    ctx.stroke();
  });

  if(tempWire) {
    const m = toWorld(mouse.x, mouse.y);
    let d = m;
    if(targetPort && targetPort.isInput) {
      const p = targetPort.parent.getPortPos(true, targetPort.idx);
      d = {x:p.x, y:p.y};
    }
    const s = tempWire.startPart.getPortPos(false, tempWire.startIdx);
    ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(d.x, d.y);
    ctx.strokeStyle = '#888'; ctx.lineWidth=2; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
  }

  parts.forEach(p => p.draw());

  if(state === STATE.SELECTING) {
    const s = toWorld(mouse.downX, mouse.downY);
    const c = toWorld(mouse.x, mouse.y);
    ctx.strokeStyle = COLORS.select; ctx.lineWidth = 1/view.scale;
    ctx.setLineDash([4/view.scale, 2/view.scale]);
    ctx.strokeRect(s.x, s.y, c.x-s.x, c.y-s.y);
    ctx.setLineDash([]);
  }
  ctx.restore();
  requestAnimationFrame(loop);
}

function hitTestWire(mx, my) {
  const threshold = 5 / view.scale;
  for(let w of wires) {
    const p1 = w.source.getPortPos(false, w.sourceIdx);
    if (w.targetIdx >= w.target.inputs.length) continue;
    const p2 = w.target.getPortPos(true, w.targetIdx);
    for(let t=0; t<=1; t+=0.05) {
      const x = (1-t)*(1-t)*(1-t)*p1.x + 3*(1-t)*(1-t)*t*(p1.x+30) + 3*(1-t)*t*t*(p2.x-30) + t*t*t*p2.x;
      const y = (1-t)*(1-t)*(1-t)*p1.y + 3*(1-t)*(1-t)*t*(p1.y) + 3*(1-t)*t*t*(p2.y) + t*t*t*p2.y;
      if(Math.hypot(mx-x, my-y) < threshold) return w;
    }
  }
  return null;
}

function drag(e, type) { e.dataTransfer.setData('text/plain', type); }
canvas.addEventListener('dragover', e => e.preventDefault());
canvas.addEventListener('drop', e => { 
  e.preventDefault(); const type = e.dataTransfer.getData('text/plain'); 
  if(type) addPart(type, e.clientX, e.clientY); 
});

function addPart(type, cx, cy) {
  let wPos;
  const r = canvas.getBoundingClientRect();
  if(cx !== undefined && cy !== undefined) {
    wPos = toWorld(cx - r.left, cy - r.top);
  } else {
    wPos = toWorld(width/2, height/2);
  }
  parts.push(new Part(type, wPos.x - 20, wPos.y - 20));
  pushHistory();
  statusEl.innerText = txt('status_placed', type);
}

function deletePartAt(cx, cy) {
  const r = canvas.getBoundingClientRect();
  const w = toWorld(cx - r.left, cy - r.top);
  const hit = parts.slice().reverse().find(p => p.hitTest(w.x, w.y));
  if(hit) {
    if(hit.oscillator) hit.oscillator.stop();
    parts = parts.filter(p => p !== hit);
    wires = wires.filter(wire => wire.source !== hit && wire.target !== hit);
    pushHistory();
    return;
  }
  const hitWire = hitTestWire(w.x, w.y);
  if(hitWire) { wires = wires.filter(w => w !== hitWire); pushHistory(); }
}

canvas.addEventListener('mousedown', e => {
  if(audioCtx.state === 'suspended') audioCtx.resume();
  const r = canvas.getBoundingClientRect();
  mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top;
  mouse.downX = mouse.x; mouse.downY = mouse.y;
  mouse.dragStartX = mouse.x; mouse.dragStartY = mouse.y;
  mouse.downPart = null; hasDraggedPart = false;

  const w = toWorld(mouse.x, mouse.y);
  if(isSpacePressed || e.button === 1 || mode === 'pan') { state = STATE.PANNING; canvas.style.cursor = 'grabbing'; return; }
  if(e.button === 2) { deletePartAt(e.clientX, e.clientY); return; }

  const distLimit = Math.min(20, 15 / view.scale);
  for(let p of parts) {
    if(p.type === 'Label') continue;
    for(let i=0; i<p.outputs.length; i++) {
      const pos = p.getPortPos(false, i);
      let limit = distLimit; if(p.type === 'Joint') limit = Math.max(limit, 12);
      if(Math.hypot(w.x-pos.x, w.y-pos.y) < limit) { state = STATE.WIRING; tempWire = { startPart: p, startIdx: i }; return; }
    }
  }

  const hit = parts.slice().reverse().find(p => p.hitTest(w.x, w.y));
  if(hit) {
    if(hit.type === 'Button' || hit.type === 'KeyInput') hit.active = true;
    if(!e.shiftKey && !selectedParts.includes(hit)) { selectedParts = [hit]; selectedWires = []; }
    else if(e.shiftKey && !selectedParts.includes(hit)) selectedParts.push(hit);
    state = STATE.DRAGGING; mouse.downPart = hit;
    dragOffsets.clear();
    selectedParts.forEach(p => dragOffsets.set(p, {dx: w.x - p.x, dy: w.y - p.y}));
    return;
  }
  const hitWire = hitTestWire(w.x, w.y);
  if(hitWire) { selectedWires = [hitWire]; selectedParts = []; return; }
  if(!e.shiftKey) { selectedParts = []; selectedWires = []; }
  state = STATE.SELECTING;
});

canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  const dx = (e.clientX - r.left) - mouse.x; const dy = (e.clientY - r.top) - mouse.y;
  mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top;
  const w = toWorld(mouse.x, mouse.y);

  if(state === STATE.PANNING) { 
    view.x -= dx; view.y -= dy; 
    syncScrollToView();
  }
  else if(state === STATE.DRAGGING) {
    if(Math.hypot(mouse.x - mouse.dragStartX, mouse.y - mouse.dragStartY) > 5) {
      hasDraggedPart = true;
      if(mouse.downPart && (mouse.downPart.type==='Button'||mouse.downPart.type==='KeyInput')) { mouse.downPart.active = false; }
    }
    selectedParts.forEach(p => {
      const off = dragOffsets.get(p);
      if(off) { p.x = snap(w.x - off.dx); p.y = snap(w.y - off.dy); }
    });
  }
  else if(state === STATE.WIRING) {
    targetPort = null;
    const distLimit = Math.min(20, 15 / view.scale);
    for(let p of parts) {
      if(p === tempWire.startPart) continue;
      for(let i=0; i<p.inputs.length; i++) {
        const pos = p.getPortPos(true, i);
        let limit = distLimit; if(p.type === 'Joint') limit = Math.max(limit, 12);
        if(Math.hypot(w.x-pos.x, w.y-pos.y) < limit) { targetPort = { parent: p, idx: i, isInput: true }; }
      }
    }
  }
});

canvas.addEventListener('mouseup', e => {
  if(state === STATE.PANNING) { state = STATE.IDLE; canvas.style.cursor = isSpacePressed ? 'grab' : 'default'; }
  else if(state === STATE.DRAGGING) {
    if(!hasDraggedPart && mouse.downPart) {
      if(mouse.downPart.type === 'Switch') { mouse.downPart.active = !mouse.downPart.active; pushHistory(); }
    }
    if(mouse.downPart && (mouse.downPart.type==='Button'||mouse.downPart.type==='KeyInput')) { mouse.downPart.active = false; }
    if(hasDraggedPart) pushHistory();
    state = STATE.IDLE;
  }
  else if(state === STATE.WIRING && targetPort) {
    wires = wires.filter(w => !(w.target === targetPort.parent && w.targetIdx === targetPort.idx));
    wires.push({ source: tempWire.startPart, sourceIdx: tempWire.startIdx, target: targetPort.parent, targetIdx: targetPort.idx, color: null });
    pushHistory();
  }
  else if(state === STATE.SELECTING) {
    const wS = toWorld(mouse.downX, mouse.downY); const wE = toWorld(mouse.x, mouse.y);
    const x1=Math.min(wS.x,wE.x), y1=Math.min(wS.y,wE.y), x2=Math.max(wS.x,wE.x), y2=Math.max(wS.y, wE.y);
    const newSel = parts.filter(p => p.x+p.w>x1 && p.x<x2 && p.y+p.h>y1 && p.y<y2);
    if(e.shiftKey) newSel.forEach(p => { if(!selectedParts.includes(p)) selectedParts.push(p); });
    else selectedParts = newSel;
  }
  if(state !== STATE.PANNING) state = STATE.IDLE;
  tempWire = null; targetPort = null; mouse.downPart = null;
});

function editPart(hit) {
  let changed = false;
  if(hit.type==='ROM') {
    const str = prompt(txt('prompt_rom'), hit.data.map(v=>v.toString(16)).join(' '));
    if(str) { hit.data = str.split(' ').map(v=>parseInt(v,16)||0).slice(0,16); changed=true;}
  } else if(hit.type==='KeyInput') {
    const k = prompt(txt('prompt_key'), hit.assignedKey);
    if(k){hit.assignedKey=k; changed=true;}
    if(confirm(txt('confirm_toggle'))) hit.isToggleMode=true; else hit.isToggleMode=false;
  } else if(hit.type==='HexDisp') {
    const d = prompt(txt('prompt_digits'), hit.digits || 1);
    const num = parseInt(d);
    if(num >= 1 && num <= 8) {
      hit.digits = num; hit.w = 50 * num;
      hit.def.in = num * 4; hit.inputs = new Array(hit.def.in).fill(false);
      changed=true;
    }
  } else if(hit.type==='Matrix' || hit.type==='ColorMatrix') {
    const r = parseInt(prompt(txt('prompt_rows'), hit.rows||8));
    const c = parseInt(prompt(txt('prompt_cols'), hit.cols||8));
    if(r>0 && c>0) {
      const defaultPitch = 12.5; const autoSize = c * defaultPitch;
      const sizeStr = prompt(txt('prompt_size', autoSize), "");
      let newW = autoSize; let newH = r * defaultPitch;
      if(sizeStr) { const s = parseInt(sizeStr); if(s > 0) { newW = s; newH = s * (r/c); } }
      hit.rows = r; hit.cols = c; hit.w = newW; hit.h = newH;
      if(hit.type==='Matrix') hit.def.in = r + c; else hit.def.in = r + c * 3;
      hit.inputs = new Array(hit.def.in).fill(false);
      hit.gridState = null;
      changed=true;
    }
  } else if(hit.label !== undefined) {
    const val = prompt(txt('prompt_label'), hit.label);
    if(val!==null) {
      hit.label = val;
      if(['Clock','Delay','Buzzer'].includes(hit.type)) Object.assign(hit, {interval:parseInt(val)||500, delayTime:parseInt(val)||1000, freq:parseInt(val)||440});
      changed=true;
    }
  }
  if(changed) pushHistory();
}

window.addEventListener('keydown', e => {
  if(modal.style.display === 'flex') return;
  if(e.code === 'Space' && !isSpacePressed) { isSpacePressed = true; if(state === STATE.IDLE) canvas.style.cursor = 'grab'; e.preventDefault(); }
  const isCtrl = e.ctrlKey || e.metaKey;
  if(isCtrl && e.key.toLowerCase()==='z') { undo(); e.preventDefault(); }
  if(isCtrl && e.key.toLowerCase()==='c') { copySelection(); e.preventDefault(); }
  if(isCtrl && e.key.toLowerCase()==='v') { pasteSelection(); e.preventDefault(); }
  if(e.key === 'Delete' || e.key === 'Backspace') {
    if(selectedParts.length > 0) deleteSelected();
    if(selectedWires.length > 0) { wires = wires.filter(w => !selectedWires.includes(w)); selectedWires = []; pushHistory(); }
  }
  if(e.key === 'Escape') { state = STATE.IDLE; tempWire = null; selectedParts = []; selectedWires = []; canvas.style.cursor = 'default'; }
  if(e.key.toLowerCase() === 'e' && selectedParts.length === 1) { editPart(selectedParts[0]); }
  if(e.key.toLowerCase() === 'c' && selectedWires.length > 0) {
    selectedWires.forEach(w => { let idx = WIRE_COLORS.indexOf(w.color); idx = (idx + 1) % WIRE_COLORS.length; w.color = WIRE_COLORS[idx]; });
    pushHistory();
  }
  parts.forEach(p => {
    if (p.type === 'KeyInput' && e.key.toLowerCase() === p.assignedKey.toLowerCase()) {
      if (p.isToggleMode) { if (!p.isKeyPressed) { p.active = !p.active; p.outputs[0] = p.active; } }
      else { p.active = true; p.outputs[0] = true; }
      p.isKeyPressed = true;
    }
  });
});

window.addEventListener('keyup', e => {
  if(e.code === 'Space') { isSpacePressed = false; if(state === STATE.PANNING) state = STATE.IDLE; canvas.style.cursor = 'default'; }
  parts.forEach(p => {
    if (p.type === 'KeyInput' && e.key.toLowerCase() === p.assignedKey.toLowerCase()) {
      if (!p.isToggleMode) { p.active = false; p.outputs[0] = false; }
      p.isKeyPressed = false;
    }
  });
});

canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const z = Math.exp(e.deltaY < 0 ? 0.1 : -0.1);
  const newScale = view.scale * z;
  if (newScale > 0.1 && newScale < 5.0) {
    const wx = (mouse.x + view.x)/view.scale;
    const wy = (mouse.y + view.y)/view.scale;
    view.x += wx * (newScale - view.scale);
    view.y += wy * (newScale - view.scale);
    view.scale = newScale;
    syncScrollToView();
  }
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

function createCustomChip() {
  if(selectedParts.length === 0) { alert(txt('alert_select_chip')); return; }
  const name = prompt(txt('prompt_chip_name'), "MyChip");
  if(!name) return;
  const inPins = selectedParts.filter(p => p.type==='PinIn').sort((a,b)=>a.y-b.y);
  const outPins = selectedParts.filter(p => p.type==='PinOut').sort((a,b)=>a.y-b.y);
  if(inPins.length===0 && outPins.length===0 && !confirm(txt('confirm_no_pins'))) return;
  let minX=Infinity, minY=Infinity;
  selectedParts.forEach(p => { if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; });
  const chipParts = selectedParts.map(p => ({
    id: p.id, type: p.type, x: p.x - minX, y: p.y - minY,
    label: p.label, interval: p.interval, delayTime: p.delayTime, freq: p.freq,
    assignedKey: p.assignedKey, data: p.data, digits: p.digits, rows: p.rows, cols: p.cols
  }));
  const chipWires = wires.filter(w => selectedParts.includes(w.source) && selectedParts.includes(w.target)).map(w => ({
    srcId: w.source.id, srcIdx: w.sourceIdx, tgtId: w.target.id, tgtIdx: w.targetIdx, color: w.color
  }));
  customDefs[name] = {
    w: 60, h: Math.max(40, Math.max(inPins.length, outPins.length)*20+20),
    in: inPins.length, out: outPins.length,
    color: '#5c6bc0', label: name,
    parts: chipParts, wires: chipWires
  };
  addChipToSidebar(name);
  selectedParts = [];
  pushHistory();
  statusEl.innerText = txt('status_ic_created', name);
}

function addChipToSidebar(name) {
  const div = document.createElement('div');
  div.className = 'tool-btn';
  div.draggable = true;
  div.innerHTML = `<span class="icon">ğŸ§©</span> ${name}`;
  div.onclick = () => addPart(name);
  div.ondragstart = (e) => drag(e, name);
  document.getElementById('user-chips-list').appendChild(div);
}

function openIO() {
  const data = {
    customDefs,
    parts: parts.map(p=>({ id:p.id, type:p.type, x:p.x, y:p.y, label:p.label, assignedKey:p.assignedKey, data:p.data, digits:p.digits, rows:p.rows, cols:p.cols, interval:p.interval })),
    wires: wires.map(w=>({srcId:w.source.id, srcIdx:w.sourceIdx, tgtId:w.target.id, tgtIdx:w.targetIdx, color:w.color}))
  };
  ioText.value = JSON.stringify(data);
  modal.style.display = 'flex';
}
function closeIO() { modal.style.display = 'none'; }
function copyIO() { ioText.select(); document.execCommand('copy'); alert(txt('alert_copied')); }
function loadFromText() { try { loadData(JSON.parse(ioText.value)); closeIO(); pushHistory(); } catch(e) { alert(txt('alert_invalid')); } }

function loadFile(input) {
  const file = input.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (e) => { loadData(JSON.parse(e.target.result)); history=[]; pushHistory(); };
  reader.readAsText(file);
  input.value = '';
}
function saveFile() { openIO(); }

function loadData(d) {
  customDefs = d.customDefs || {};
  document.getElementById('user-chips-list').innerHTML = '';
  Object.keys(customDefs).forEach(name => addChipToSidebar(name));
  parts = []; wires = [];
  if(d.parts) d.parts.forEach(p => {
    const np = new Part(p.type, p.x, p.y);
    Object.assign(np, p);
    if(np.type === 'HexDisp' && np.digits) { np.def.in = np.digits*4; np.inputs = new Array(np.def.in).fill(false); np.w = 50*np.digits; }
    if(np.type === 'Matrix' && np.rows) { np.def.in = np.rows+np.cols; np.inputs = new Array(np.def.in).fill(false); }
    if(np.type === 'ColorMatrix' && np.rows) { np.def.in = np.rows+np.cols*3; np.inputs = new Array(np.def.in).fill(false); }
    parts.push(np);
  });
  if(d.wires) d.wires.forEach(w => {
    const s = parts.find(p=>p.id===w.srcId);
    const t = parts.find(p=>p.id===w.tgtId);
    if(s && t) wires.push({ source:s, sourceIdx:w.sourceIdx, target:t, targetIdx:w.tgtIdx, color:w.color });
  });
  syncScrollToView();
}

function pushHistory() {
  if(isUndoRedo) return;
  const stateStr = JSON.stringify({
    customDefs,
    parts: parts.map(p=>({ id:p.id, type:p.type, x:p.x, y:p.y, label:p.label, assignedKey:p.assignedKey, data:p.data, digits:p.digits, rows:p.rows, cols:p.cols, interval:p.interval })),
    wires: wires.map(w=>({srcId:w.source.id, srcIdx:w.sourceIdx, tgtId:w.target.id, tgtIdx:w.targetIdx, color:w.color}))
  });
  if(historyIndex < history.length-1) history = history.slice(0, historyIndex+1);
  history.push(stateStr);
  if(history.length>MAX_HISTORY) history.shift(); else historyIndex++;
}
setTimeout(pushHistory, 100);

function undo() {
  if(historyIndex>0) { historyIndex--; isUndoRedo=true; loadData(JSON.parse(history[historyIndex])); isUndoRedo=false; statusEl.innerText="Undo"; }
}

function deleteSelected() {
  parts.forEach(p=>{ if(selectedParts.includes(p) && p.oscillator) p.oscillator.stop(); });
  parts = parts.filter(p=>!selectedParts.includes(p));
  wires = wires.filter(w=>!selectedParts.includes(w.source) && !selectedParts.includes(w.target));
  selectedParts=[];
  pushHistory();
}

function copySelection() {
  if(selectedParts.length===0) return;
  const iWires = wires.filter(w=>selectedParts.includes(w.source)&&selectedParts.includes(w.target));
  clipboard = {
    parts: selectedParts.map(p=>{const c=Object.assign({},p); delete c.oscillator; return c;}),
    wires: iWires.map(w=>({srcId:w.source.id, srcIdx:w.sourceIdx, tgtId:w.target.id, tgtIdx:w.targetIdx, color:w.color}))
  };
}

function pasteSelection() {
  if(!clipboard) return;
  const center = toWorld(width/2, height/2);
  let minX=Infinity, minY=Infinity;
  clipboard.parts.forEach(p=>{if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y;});
  selectedParts=[];
  const map={};
  clipboard.parts.forEach(p=>{
    const np = new Part(p.type, 0, 0);
    Object.assign(np, p);
    np.id = 'p_'+Date.now()+'_'+Math.floor(Math.random()*100000);
    np.x = center.x + (p.x - minX) - 50;
    np.y = center.y + (p.y - minY) - 50;
    if(p.data) np.data = [...p.data];
    if(np.type === 'HexDisp' && np.digits) { np.def.in = np.digits*4; np.inputs = new Array(np.def.in).fill(false); }
    if(np.type === 'Matrix' && np.rows) { np.def.in = np.rows+np.cols; np.inputs = new Array(np.def.in).fill(false); np.gridState = null; }
    if(np.type === 'ColorMatrix' && np.rows) { np.def.in = np.rows+np.cols*3; np.inputs = new Array(np.def.in).fill(false); np.gridState = null; }
    parts.push(np);
    selectedParts.push(np);
    map[p.id]=np;
  });
  clipboard.wires.forEach(w=>{
    const s=map[w.srcId], t=map[w.tgtId];
    if(s&&t) wires.push({source:s, sourceIdx:w.srcIdx, target:t, targetIdx:w.tgtIdx, color:w.color});
  });
  pushHistory();
}

function setMode(m) {
  mode=m;
  document.querySelectorAll('.btn-mode').forEach(b=>b.classList.remove('active'));
  if(m==='pointer')document.getElementById('btn-ptr').classList.add('active');
  if(m==='pan')document.getElementById('btn-pan').classList.add('active');
  if(m==='select')document.getElementById('btn-sel').classList.add('active');
}

function clearAll() {
  if(!confirm(txt('confirm_clear'))) return;
  parts.forEach(p=>{if(p.oscillator)p.oscillator.stop();});
  parts=[]; wires=[]; selectedParts=[]; selectedWires=[]; customDefs={};
  document.getElementById('user-chips-list').innerHTML='';
  pushHistory();
}

updateUIText();
loop();
</script>
</body>
</html>
